Row types
fun (tbl) { for (x <-- tbl) where (x.id == 42) [x] }
stdout : fun : (TableHandle((id:Int|a::Base),(|_::Base),(|_::Base))) {}-> [(id:Int|a::Base)]

Onetuple with unit
(1=())
stdout : (1 = ()) : (1:())

Alias record functional update
tests/roundtrip/record_update.links
filemode : true
stdout : (q = [3, 1, 2]) : Q

Recursive effect
fun w(g) { handle(g()) { case Return(()) -> () case F(h, res) -> w(h) }} w
args : --enable-handlers
stdout : fun : (() { |(mu a . F:(() { |a}~> ()) {}-> _::Any,wild:()|c)}~> ()) {F{_}|c}~> ()
ignore : Not currently roundtrippable (with or without the | in { |(mu ...)} )

Recursive variant
sig f : ([|(mu a. Op:() { |a}-> ())|]) {}-> () fun f(_) { () } f
stdout : fun : ([|(mu a . Op:() { |a}-> ())|]) {}-> ()

Recursive record (simulating OOP)
tests/roundtrip/record_oop.links
filemode : true
stdout : (getName = fun, name = "Object") : (name:String|(mu a . getName:((name:String|a)) -> String))
ignore : pending parser allowing recursive variables in records (#993)
